package main

import (
	"fmt"
	"crypto/sha256"
	"io"
	"crypto/sha1"
	"crypto/md5"
	"golang.org/x/crypto/scrypt"
)
/*
todo  1）如果你是普通用户，那么我们建议使用LastPass进行密码存储和生成，对不同的网站使用不同的密码；
todo 2）如果你是开发人员， 那么我们强烈建议你采用专家方案进行密码存储。
 */


func init() {
	fmt.Println("passWord 密码的储存的问题")
}

func main() {
	fmt.Println("过去一段时间以来, 许多的网站遭遇用户密码数据泄露事件, 这其中包括顶级的互联网企业–Linkedin, 国内诸如CSDN，该事件横扫整个国内互联网，随后又爆出多玩游戏800万用户资料被泄露，另有传言人人网、开心网、天涯社区、世纪佳缘、百合网等社区都有可能成为黑客下一个目标。层出不穷的类似事件给用户的网上生活造成巨大的影响，人人自危，因为人们往往习惯在不同网站使用相同的密码，所以一家“暴库”，全部遭殃。")




	//普通方案
	//目前用的最多的密码存储方案是将明文密码做单向哈希后存储，单向哈希算法有一个特征：无法通过哈希后的摘要(digest)恢复原始数据，这也是“单向”二字的来源。常用的单向哈希算法包括SHA-256, SHA-1, MD5等
	 demo1()

	//进阶方案
    demo2()

    //专家方案
	demo3()



}
/*
上面的进阶方案在几年前也许是足够安全的方案，因为攻击者没有足够的资源建立这么多的rainbow table。 但是，时至今日，因为并行计算能力的提升，这种攻击已经完全可行。
怎么解决这个问题呢？只要时间与资源允许，没有破译不了的密码，所以方案是:故意增加密码计算所需耗费的资源和时间，使得任何人都不可获得足够的资源建立所需的rainbow table。
这类方案有一个特点，算法中都有个因子，用于指明计算密码摘要所需要的资源和时间，也就是计算强度。计算强度越大，攻击者建立rainbow table越困难，以至于不可继续。
这里推荐scrypt方案，scrypt是由著名的FreeBSD黑客Colin Percival为他的备份服务Tarsnap开发的。
 */
func demo3() {
	//通过上面的方法可以获取唯一的相应的密码值，这是目前为止最难破解的。
	dk,err := scrypt.Key([]byte("some password"), []byte("shimingfgf"), 16384, 8, 1, 32)

	fmt.Println("err==",err)
	fmt.Println("dk==",dk)


}
/*
通过上面介绍我们知道黑客可以用rainbow table来破解哈希后的密码，很大程度上是因为加密时使用的哈希算法是公开的。如果黑客不知道加密的哈希算法是什么，那他也就无从下手了。

一个直接的解决办法是，自己设计一个哈希算法。然而，一个好的哈希算法是很难设计的——既要避免碰撞，又不能有明显的规律，做到这两点要比想象中的要困难很多。因此实际应用中更多的是利用已有的哈希算法进行多次哈希。

但是单纯的多次哈希，依然阻挡不住黑客。两次 MD5、三次 MD5之类的方法，我们能想到，黑客自然也能想到。特别是对于一些开源代码，这样哈希更是相当于直接把算法告诉了黑客。

没有攻不破的盾，但也没有折不断的矛。现在安全性比较好的网站，都会用一种叫做“加盐”的方式来存储密码，也就是常说的 “salt”。他们通常的做法是，先将用户输入的密码进行一次MD5（或其它哈希算法）加密；将得到的 MD5 值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）。
 */
func demo2() {

	fmt.Println("现在安全性比较好的网站，都会用一种叫做“加盐”的方式来存储密码，也就是常说的 “salt”。他们通常的做法是，先将用户输入的密码进行一次MD5（或其它哈希算法）加密；将得到的 MD5 值前后加上一些只有管理员自己知道的随机串，再进行一次MD5加密。这个随机串中可以包括某些固定的串，也可以包括用户名（用来保证每个用户加密使用的密钥都不一样）")

   // 假定用户名 为：shiming 密码为：123456
    d:=md5.New()

    io.WriteString(d,"123456")

    pwdmd5:= fmt.Sprintf("%x",d.Sum(nil))
   //pwdmd5= e10adc3949ba59abbe56e057f20f883e
    fmt.Println("pwdmd5=",pwdmd5)
	//指定两个 salt： salt1 = @#$%   salt2 = ^&*()
	salt1 := "@#$%"
	salt2 := "^&*()"

	io.WriteString(d,salt1)
	io.WriteString(d,"shiming")
	io.WriteString(d,salt2)
	io.WriteString(d,pwdmd5)

	last:=fmt.Sprintf("%x",d.Sum(nil))
	fmt.Println("最后得到的值是：",last)


}
/*
单向哈希有两个特性：
1）同一个密码进行单向哈希，得到的总是唯一确定的摘要。
2）计算速度快。随着技术进步，一秒钟能够完成数十亿次单向哈希计算。

 */
func demo1() {
	h:=sha256.New()
	fmt.Println("h==",h)
	io.WriteString(h,"shiming")
	fmt.Printf("% x",h.Sum(nil))
    fmt.Println("-------------------------")

	 s:=sha1.New()
	 fmt.Println("s==",s)
	io.WriteString(s,"shiming")
	 //这个输出出来时 16 进制的
    fmt.Printf("% x",s.Sum(nil))
	 //这个输出出来是  10 进制
	fmt.Println("-------------------------",s.Sum(nil))


	 d:=md5.New()
     fmt.Println("old  d=",d.Sum(nil))
	 io.WriteString(d,"第四名")
	 fmt.Println("new  d =",d.Sum(nil))
	 fmt.Printf("% x",d.Sum(nil))


	//结合上面两个特点，考虑到多数人所使用的密码为常见的组合，攻击者可以将所有密码的常见组合进行单向哈希，得到一个摘要组合, 然后与数据库中的摘要进行比对即可获得对应的密码。这个摘要组合也被称为rainbow table。
	//因此通过单向加密之后存储的数据，和明文存储没有多大区别。因此，一旦网站的数据库泄露，所有用户的密码本身就大白于天下。



}