package main

import "fmt"

func main() {

	//Go语言中数组、字符串和切片三者是密切相关的数据结构。 todo 这三种数据类型，在底层原始数据有着相同的内存结构，            在上层，因为语法的限制而有着不同的行为表现。首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的。Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理。要理解数组、字符串和切片三种不同的处理方式的原因需要详细了解它们的底层数据结构
	fmt.Println("数组、字符串、切片")

	var a [3]int                    // 定义一个长度为3的int类型数组, 元素全部为0
	var b = [...]int{1, 2, 3}       // 定义一个长度为3的int类型数组, 元素为 1, 2, 3
	// todo  第三种方式是以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。这种初始化方式和map[int]Type类型的初始化语法类似。数组的长度以出现的最大的索引为准，没有明确初始化的元素依然用0值初始化
	var c = [...]int{2: 3, 1: 2,}    // 定义一个长度为3的int类型数组, 元素为 0, 2, 3
	var d = [...]int{1, 2, 4: 5, 6} // 定义一个长度为6的int类型数组, 元素为 1, 2, 0, 0, 5, 6

	fmt.Println(a,b,c,d)



	//Go语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如C语言的数组），而是一个完整的值。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。

	var aa = [...]int{1, 2, 3} // a 是一个数组
	var bb = &a                // b 是指向数组的指针
    fmt.Println(aa,"*****",bb)
	fmt.Println(a[0], a[1])   // 打印数组的前2个元素
	fmt.Println(b[0], b[1])   // 通过数组指针访问数组元素的方式和数组类似

	for i, v := range b {     // 通过数组指针迭代数组的元素
		fmt.Println(i, v)
	}


}

