
# GoDemo <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:"/>
### Old目录-->以前学习的Demo，停止更新

#### 2018.7.26 学习Deployment部署和Maintenance维护
* 1、日记应用 尼玛逼啊！还要一个依赖：https://github.com/golang/sys 
* 2、seelog的Demo完成
* 3、错误的处理：panic和recover是针对自己开发package里面实现的逻辑，针对一些特殊情况来设计。
* 5、错误的处理
*  6、网站错误处理：数据库错误（连接错误、查询错误、数据错误）；应用运行时错误（文件系统和权限、第三方应用和接口错误）；HTTP错误；操作系统出错；网络出错
*  7、错误处理的目标：通知访问用户出现错误了；记录错误；回滚当前的请求操作；保证现有程序可运行可服务
*  8、如何处理错误
*  9、应用部署： daemon：Go程序还不能实现daemon，详细的见这个Go语言的bug：<http://code.google.com/p/go/issues/detail?id=227>，大概的意思说很难从现有的使用的线程中fork一个出来，因为没有一种简单的方法来确保所有已经使用的线程的状态一致性问题
* 10、Supervisord可惜啊，不支持window系统啊日了狗 
* 11、备份和恢复

### New20180730目录,重新学习了一本书来了解更深刻的原理
#### 说明一：如果见着 `todo  image`的字样，那么在`image`目录下就有图片的说明 

* 2018.7.30 
  *  数组Array
* 2018.7.31
  *  字符串、切片（slice），切片内存技巧，避免切片内存的泄露！切片类型的强制转换，sort.Ints对转换后的[]int排序的性能要比用sort.Float64s排序的性能好一点
  *  Go语言函数的递归调用深度逻辑上没有限制，函数调用的栈是不会出现溢出错误的，因为Go语言运行时会根据需要动态地调整函数栈的大小。每个goroutine刚启动时只会分配很小的栈（4或8KB，具体依赖实现），根据需要动态调整栈的大小，栈最大可以达到GB级（依赖具体实现）。在Go1.4以前，Go的动态栈采用的是分段式的动态栈，通俗地说就是采用一个链表来实现动态栈，每个链表的节点内存位置不会发生变化。但是链表实现的动态栈对某些导致跨越链表不同节点的热点调用的性能影响较大，因为相邻的链表节点它们在内存位置一般不是相邻的，这会增加CPU高速缓存命中失败的几率。为了解决热点调用的CPU缓存命中率问题，Go1.4之后改用连续的动态栈实现，也就是采用一个类似动态数组的结构来表示栈。不过连续动态栈也带来了新的问题：当连续栈动态增长时，需要将之前的数据移动到新的内存空间，这会导致之前栈中全部变量的地址发生变化。虽然Go语言运行时会自动更新引用了地址变化的栈变量的指针，但最重要的一点是要明白Go语言中指针不再是固定不变的了（因此不能随意将指针保持到数值变量中，Go语言的地址也不能随意保存到不在GC控制的环境中，因此使用CGO时不能在C语言中长期持有Go语言对象的地址）
  *  Go语言的函数，导包方法执行的先后的顺序：通过日记输出，可以看出，先执行所有的pkg的init的方法，然后执行mian.init ，然后执行main.main 最后执行方法导入到方法
  * 我们无法知道函数参数或局部变量到底是保存在栈中还是堆中，我们只需要知道它们能够正常工作就可以了

* 2018.8.1
  * 方法：oop(面向对象的程序设计)  1、封装 2、继承 3、多态 4、抽象
  * 方法一般是面向对象编程(OOP)的一个特性 
  * 一般静态编程语言都有着严格的类型系统。过于严格的编译系统，会导致编程的效率过低 ---  go在其中取得平衡 
  * 鸭子类型：当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子
  * 面向并发的内心模型:Go语言是基于消息并发模型的集大成者，它将基于CSP模型的并发编程内置到了语言中，通过一个go关键字就可以轻易地启动一个Goroutine，与Erlang不同的是Go语言的Goroutine之间是共享内存的
  * Goroutine是Go语言特有的并发体，是一种轻量级的线程，由go关键字启动。在真实的Go语言的实现中，goroutine和系统线程也不是等价的。尽管两者的区别实际上只是一个量的区别，但正是这个量变引发了Go语言并发编程质的飞跃
  
  